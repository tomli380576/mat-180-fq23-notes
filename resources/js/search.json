[[{"l":"Home","p":["This is the landing page for MAT 180 notes."]}],[{"i":"w1---basic-inventory-models","l":"W1 - Basic Inventory Models"},{"i":"economic-order-quantity-model-eoq","l":"Economic Order Quantity Model (EOQ)"},{"l":"Scenario. Coffee Shop Inventory","p":["A coffee shop needs to decide how much coffee beans to purchase and how frequently should they purchase. Factors to consider include:","Beans could expire","Storage cost","Uncertainty in demand / supply. There could be a surge in customers","Possible discounts for bulk purchase","Contracts with bean providers (amortize fixed ordering)"]},{"l":"Assumption","p":["Everything is deterministic","Demand is constant (always the same amount of customers)","Only 1 product (1 type of coffee)","No backorders (coffee bean provider is always available)","Zero load time (supply instantly appears when ordered)","No discounts (coffee is always flat rate)"]},{"l":"Variables","p":["Total annual demand (in this case pounds of coffee needed per year)","Fixed cost of an order (shipping & handling, etc.)","Unit cost of each item (price per pound of coffee)","Holding / Storage cost per item per year","Quantity"]},{"i":"optimal-order-quantity-","l":"Optimal Order Quantity Q^*","p":["Since orders are fulfilled instantly, we only order a batch of coffee beans when stock goes to 0.","We can compute the following:","Then the total cost \\text{TC} is:","Let the purchase quantity that minimizes total cost be Q^*:","The optimal total cost can be found by plugging in Q^* into \\text{TC}:","We can find the optimum Q^* when we graph the total cost at the intersection of holding cost y(Q)=\\frac {hQ}{2} and ordering cost y(Q) = \\frac{fd}{Q}."]},{"i":"derivation-of-text-tc-q","l":"**Derivation** of $\\text{TC}(Q^*)$"},{"l":"Sensitivity Analysis","p":["Since Q^* is likely not an integer, we are interested in what will happen if we pick a nearby integer.","In particular, we could find a range of Q such that \\text{TC}(Q) is within some range around the optimal total cost."]},{"i":"badge-variant-warning-text-example-1","l":"[!badge variant=\"warning\" text=\"Example 1\"]","p":["Find a range of Q such that \\text{TC} is within 1% from the optimum."]},{"l":"The News Vendor Model","p":["A newspaper vendor needs to decide how many newspapers to buy from the news publisher. Newspapers expire in a day. Expired newspapers can be salvaged (returned to vendor) for a lower price."]},{"i":"variables-1","l":"Variables","p":["Combining the 2 cases we have the expected profit:","Cost of each newspaper","Discrete R.V., the uncertain demand of newspapers","Fix d=i. If i\\geqslant B, then:","For simplicity assume that i is finite, so i=0,1,2\\dots, M for some M\\in\\N.","If i < B, then:","Sale price of each newspaper","Salvage price, sale price for expired newspapers. (e.g. recycling the paper)","Since d is a discrete random variable, we have a probability mass function:","The 3 prices have the following inequality:","The number of newspapers to buy from the supplier","The objective is to maximize the expected value of \\text{TP} by picking the best B.","The probability distribution of newspaper demand. d\\sim P","The total profit \\text{TP} is given by:","Then the expectation is:","We either sold all the newspapers or have to salvage some of them."]},{"l":"Optimum","p":["For simpler notation let f(B) be the expected profit \\Bbb E[\\text{TP}] when we purchase B newspapers.","Rearrange:","Now we consider the finite difference of f(B+1) - f(B).","Notice that we got the c.d.f. of d to appear in the difference:","Plug in Q:","If the finite difference is positive, that means we are making more money by buying more newspapers. Otherwise we are losing money or not making more.","This method requires s<c<p.","Let \\frac{p-c}{p-s} be the critical ratio. The smallest B such that:","is the optimum number of newspapers to buy, B^*."]},{"i":"badge-variant-success-text-explanation-e-1","l":"[!badge variant=\"success\" text=\"Explanation E.1\"]","p":["Since the profit when i>B is fixed, we can pull it out of the sum:"]},{"l":"Sensitivity","p":["Suppose the salvage price s increases and all else equal."]},{"l":"Buying services"},{"l":"Scenario. Signing a contract","p":["Suppose we want to sign a contract with a lighting company to purchase their maintenance services. The amount of services to put on the contract will be fixed. But we don’t know how many services we will actually need.","Contract too much: We get refunded for remaining services at a less price","Contract too little: We need to pay more for the extra services on the fly"]},{"i":"variables-2","l":"Variables","p":["A discrete random variable, the uncertain number of services we actually need","Price of each service on the contract","Refund price","Price of extra services","PMF of D, same as \\Bbb P(D=d), in this case d = 0,1,2,\\dots","CDF of D, same as \\Bbb P(D\\leqslant d)","The number of services to buy from the contracting company","The objective is to minimize the expected total cost \\text {TC} by picking the optimal B.","The expression for \\Bbb E[{\\text {TC}}] is:","Here we notice that d-B and B-d can be expressed as positive & negative parts.","where (d-B)^+ = \\max(d-B, 0) and (d-B)^- = \\min(d-B, 0).","Strat. Critical Ratio Method still works because \\Bbb E[\\text{TC}] is dual of \\Bbb E[\\text{Profit}] from the newsvenfor problem.","Minimizing \\Bbb E[\\text{TC}] is the same as maximizing \\Bbb E[\\text{Profit}]."]}],[{"i":"w2---linear-programming","l":"W2 - Linear Programming","p":["We will use \\bold x to indicate a vector, x_i to indicate the element of \\bold x. The \\leqslant, \\geqslant comparators are element–wise comparison. \\bold 0 is the zero vector."]},{"l":"Linear Programming"},{"l":"Scenario. Production Problem","p":["Consider a factory that has a limited amount of resources and produces a finite number of products."]},{"l":"Variables","p":["Total number of kinds of resources","Total number of products","Amount we have for resource i","Unit profit of product j","Amount of resource i needed to make 1 unit of product j","Number of product j to make, 1\\leqslant j\\leqslant n, non negative"]},{"l":"Objective","p":["We want to maximize the total profit, which is the sum of profits over all products:"]},{"l":"Constraints","p":["For each resource i, we can’t use more than what we have:","We shouldn’t make negative number of products either:"]},{"l":"Matrix-Vector Form","p":["Where c, x are vectors in \\R^m:","and A is a m\\times n matrix:"]},{"i":"ex-1-2d-example","l":"**Ex.1** 2D Example","p":["The feasible region for this linear program"]},{"i":"duality---resource-buyer","l":"Duality - Resource Buyer","p":["Consider the resource buyer perspective. For each resource i, we have a bid price y_i."]},{"i":"objective-1","l":"Objective","p":["Minimize total cost."]},{"l":"Constraint","p":["For each product j, the price to sell all the resources needed should be greater than the profit of j."]},{"i":"matrix-vector-form-1","l":"Matrix-Vector Form","p":["This is the Dual problem of the original Primal problem","For each feasible solution \\bold x of the primal problem, and each feasible solution \\bold y of the dual problem, we have the following:","Weak Duality","Strong Duality","all linear programs have strong duality if optimal solutions \\bold x^*, \\bold y^* exists for primal and dual","The slack variables are just a vector that turns \\leqslant, \\geqslant in the constraints into equality:","Basically primal solution times dual slack is 0, dual solution times primal slack is also 0 for linear programs. The optimal objective \\zeta and \\xi are equal."]},{"i":"proof-weak-duality","l":"**Proof.** (Weak Duality)","p":["Let \\bold x, \\bold y be feasible solutions for the primal and dual problem respectively.","Then by definition of feasible, we have","We need to show \\bold c^T\\bold x\\leqslant \\bold b^T\\bold y. Plug in the definition of c^T:"]},{"i":"optimization-output--infer-dual-results-from-primal","l":"Optimization Output / Infer Dual Results from Primal","p":["A linear program can have the following statuses:","Finite, we have a finite optimal solution","Unbounded, the objective can go to \\pm\\infty","Infeasible, no solution exists that satisfies all the constraints","By strong duality, the results of Primal & Dual are linked:","Primal","Dual","Optimal","Unbounded","Infeasible","Unbounded or Infeasible"]},{"l":"Sensitivity","p":["Suppose we change one of the constraints b_i to b_i + \\Delta b_i.","Let \\zeta be the value of the objective function.","If \\Delta b_i > 0, then the new optimal \\zeta_{new} should be at least the original solution because we loosened the constraint.","If \\Delta b_i < 0, the original \\bold x^* might not be in the new feasible region. If there’s another solution, it should be at most the original because we tightened the constraint."]}],[{"i":"w3---network-flow-pt1","l":"W3 - Network Flow Pt.1"},{"l":"Transportation Problem"},{"l":"Scenario. Sending supplies to stores","p":["Suppose you own a clothing business and owns both factories and stores. Let \\bigcirc be the factories (supply nodes) and \\triangle be the stores (demand node). The supply system looks like a directed graph:","The placements are arbitrary","There’s also a unit cost to ship cloths from i to j."]},{"l":"Variables","p":["Set of supply nodes","Set of demand nodes","Supply capacity of node i","Demand at node j","Unit transportation cost to go from i to j","Amount of items to ship from supply node i to demand node j. \\forall i\\in I, j\\in J"]},{"l":"Objective","p":["We want to minimize the total shipping cost.","If d_j, s_i\\in \\Z, the solution are also integers.","If the total demand is less than total supply, the the problem is feasible.","We will see that the transportation problem is a special case of the more general network flow problem."]},{"l":"Network Flow Problem","p":["Given a graph G = (V, A), where V is the set of vertices, A is the set of arcs.","Define x_{ij} to be the flow on the arc i\\to j.","Each node i has the flow conservation constraint","For each node i,"]},{"i":"objective-1","l":"Objective","p":["Minimize the total cost. c_{ij} is the unit cost to go from i\\to j.","Flows could have upper and lower bounds:"]},{"i":"special-case-transportation-problem","l":"Special Case: Transportation Problem","p":["Continue from above, define the vertices to be:","Since there are only arcs from supply nodes to demand nodes, we can group everything into a bipartite graph.","where is the universal node u to maintain flow conservation.","Supply nodes only have arcs leaving them, causing negative flow.","The universal node can be thought of as the universal supplier that sends products to the supply nodes.","Demand nodes only receives flow, so they have positive flow.","The universal node can be thought of as the universal customer that buys everything.","Therefore the set of arcs A is given by:"]},{"l":"Decision Variables","p":["y_i and z_j are new for this model.","Amount of items to ship from supply node i to demand node j.","The flow from u to i for each supply node i","The from from j to u for each demand node j"]},{"i":"objective-2","l":"Objective","p":["Minimize the total cost.","Note that the under-braced parts are 0, because we only use y_i, z_j for flow conservation. There’s no unit cost associated with arcs from or into u."]},{"l":"Constraints","p":["For each supply node i, total flow out should equal to total flow in.","For each demand node j, total flow in should equal total flow out.","For the universal node, flow out = flow in.","Finally the bounds:","x_{ij}\\geqslant 0, can’t ship negative amount of products to demand nodes","y_i\\leqslant s_i, can’t go over the supply capacity","z_j\\geqslant d_j, meets demand","Together we have the transportation model.","The constraints are exactly the same as above."]}],[{"i":"w4---network-flow-pt2","l":"W4 - Network Flow Pt.2"},{"l":"With discontinuous cost function","p":["In the previous network flow model, the cost of an edge is linear:","Suppose now there’s a starting price d_{ij} to send any amount of flow on arc i\\to j.","Let non-negative x_{ij} be the flow of i\\to j.","We can model the initial cost with an indicator variable y_{ij}.","The total cost/objective function becomes:"]}],[{"i":"w5---dynamic-programming-pt1","l":"W5 - Dynamic Programming Pt.1"},{"l":"Shortest path as network flow","p":["Given undirected graph G = (V, E), start node s, and end node t, we want to find the shortest path s\\leadsto t.","Each edge ij\\in E has a non-negative cost c_{ij}. Typically the distance.","The \\leadsto arrow means the path from s to t, including arbitrarily many intermediate vertices."]},{"l":"Decision Variables","p":["We want to find which edge to take from E."]},{"l":"Objective","p":["Minimize the path cost.","We could solve the shortest path problem with a general LP solver, but we have more efficient algorithms."]},{"i":"dijkstras-algorithm","l":"Dijkstra’s Algorithm","p":["The following pseudocode is from my own algorithm notes but it does the same thing as what we did in class.","where queue.ExtractMin() grabs the vertex with the shortest distance."]},{"i":"ex-in-class-practice-graph","l":"**Ex.** In-class practice graph","p":["Source: Canvas, Shortest_path_problem_in_class.pdf","Running Dijkstra’s algorithm with \\text{start} = A gives us shortest path from A to every other node:"]},{"l":"Optimal Substructure","p":["Suppose s\\leadsto t is the shortest path from s to t, and v is an intermediate node.","Then the sub-path s\\leadsto v and v\\leadsto t are both shortest paths from s to v, v to t respectively."]},{"l":"Asymmetric Traveling Salesman Problem","p":["For a directed graph G = ( V, A), a non-negative cost c_{ij} for each arc i\\to j, we want to find the shortest tour (visit all nodes exactly once and return to the starting node)"]},{"l":"Decision Variable"},{"i":"objective-1","l":"Objective","p":["Minimize the total cost."]},{"l":"Constraints","p":["For each v\\in V, let the set of edges entering v be \\delta^-, edges leaving v be \\delta ^+:","We should pass through v exactly once, so 1 edge in 1 edge out."]},{"l":"Sub-tour elimination","p":["The graph should also be connected, no isolated subgraphs","We don’t want (1) basically, since there’s complete tour. [Source](Untitled%201.png)","We don’t want (1) basically, since there’s complete tour. Source"]},{"i":"the-dantzig-fulkerson-johnson-dfj-formulation","l":"The Dantzig-Fulkerson-Johnson (DFJ) formulation","p":["This constraint is what makes TSP an NP-Hard problem, the number of possible S’s is the size of the power set of V, which is {\\cal P}(V)=2^{V}"]},{"i":"the-millertuckerzemlin-mtz-formulation","l":"The Miller–Tucker–Zemlin (MTZ) formulation","p":["For each node i\\in V, label with u_i\\in\\N except the starting node.","The idea is we must go to a node that has a larger label than the current node.","See image link for source","This prevents us from going into cycles, since if we do, we will eventually travel to a node with a smaller label, which violates the constraint."]},{"l":"Symmetric TSP","p":["Now we consider a undirected graph G = (V, E), a non-negative cost c_{ij} for each edge i j. We also know that c_{ij} = c_{ji}."]},{"i":"objective-2","l":"Objective","p":["Same as the asymmetric case."]},{"i":"constraints-1","l":"Constraints","p":["Let \\delta (v) be the set of edges connected to node v:","The one edge in, one edge out constraint is:","Let \\delta(S), S\\sub V be the set of edges that have one node in S and one node not in S:","Using the DFJ formulation for sub-tour elimination, we have:"]},{"i":"dynamic-programming-dp","l":"Dynamic Programming (DP)"},{"l":"General formulation","p":["Every DP problem has the following properties:","t=1,2,\\dots ,T","s_t","v_t(s_t)","c(s_{t-1}, s_t)","If v_t(s_t) is optimal, then all the subproblems v_{t-1}(s_{t-1}) are also optimal."]},{"l":"0-1 Knapsack","p":["Given a backpack with capacity b, and n items where each item takes up capacity a_i and is worth c_i dollars. Decide which items to take."]},{"i":"objective-3","l":"Objective","p":["Let x_i be the indicator variable of whether to take item i, we want to maximize total profit:","If we don’t have the integer constraint x_i\\in\\{0,1\\}, we can just take the items with maximum profit-to-capacity ratio: \\frac{c_i}{a_i}."]},{"l":"DP Formulation","p":["The maximum item index 1, 2,\\dots,n. If we are in stage k, we only consider items 1,2,\\dots, k.","w, remaining capacity of the backpack","v_k(w), max profit given capacity w and items 1,2,\\dots k","We can try to take item k if it fits, or we can skip k."]},{"l":"Bounded Knapsack","p":["Now suppose each items has a maximum of u_i copies.","In this case we include the number of copies as part of the state, v_k(w, s_k) now represents the maximum profit with capacity w, s_k copies of item k, and using item 1\\dots k."]},{"l":"Direct TSP with dynamic programming","p":["Consider the graph G=(V,A)","The subproblem is a graph with the sam vertices, but less edges."]}],[{"i":"w6---dynamic-programming-pt2","l":"W6 - Dynamic Programming Pt.2"},{"i":"lot-sizing--generalized-inventory-problem","l":"Lot Sizing / Generalized Inventory Problem"},{"l":"Scenario. Keeping inventory","p":["Going back to the coffee shop example: A coffee shop needs to decide how much coffee beans to purchase and how frequently should they purchase. Now suppose we also own a roastery with a bunch of roasters, where we can roast our own coffee beans."]},{"l":"Variables","p":["Time period","Demand at time t","Inventory at the start of period t","Production amount at period t","Unit production cost","Unit holding cost","Fixed cost for starting production","Production cost function","Note that “period” is the interval between each timestamp"]},{"i":"stage-state-value-function","l":"Stage, State, Value Function","p":["Time t = 1, 2\\dots, T","Inventory s_t","v_t(s_t), the minimum cost from time t to T with initial inventory s_t","a_t, the production amount","The optimality equation is:","with base cases:"]},{"l":"Bounds","p":["Suppose we only have M machines, then a_t is bounded by the number of machines","The inventory capacity could be capped at D, this bounds the state:"]},{"l":"Properties of the Inventory Problem","p":["Assuming unit costs b, h are independent of time t, we have:","If it is optimal to produce during any time period t, then the starting inventory is 0","If it is optimal to produce in stage t(so a_t > 0 for some t), then it is optimal to produce an amount that exactly covers the demand for t, t+1, \\cdots, t+j for some 0\\leqslant j\\leqslant T-t.","Using the previous 2 properties, we only need to find the number of time periods j to cover when we produce. If we produce enough to cover j periods, we move to time t+j+1.","where the transition cost c_{t, t+j+1} is:","with base cases v_{T+1} = 0, s_1 = 0."]},{"l":"Stochastic Dynamic Programming"},{"l":"Markov Chain Review","p":["A discrete, time homogeneous Markov chain on state space S with transition matrix P and initial distribution \\alpha is a sequence of random states X_n\\in S such that:","\\Bbb P(X_0 = i) = \\alpha_i","Prop. Markov Property","The elements p_{ij} in P represents:","2 states i, j\\in S communicates if they are accessible from each other.","A subset of state space T\\sub S is closed if any of the states in T is ever entered, the chain cannot leave T. In terms of transition probability:","The entire state space is always closed.","It’s the i,j th entry in P^n."]},{"l":"Markov decision process with finite time","p":["For this class we assume time t is finite, t = 0,1,2,\\dots, N."]},{"i":"variables-1","l":"Variables","p":["State at time t","Action at time t","Reward function for the state, action pair at time t","Transition probability of actually going to state s_{t+1} given we took action a_t at state s_t.","Reward if we end on state s_N"]},{"l":"Optimality Equation","p":["Starting with the deterministic case, we want to see with action at time t maximizes / minimizes the reward.","For the stochastic case, replace v_{t+1} with expected value, since it’s possible we might not get to the state s_{t+1}. The next state became a random variable:","Expand with the definition of \\Bbb E:","with base cases v_N(s_N) = R(s_N) for some final reward function R and each possible end state s_N\\in S."]},{"i":"decision-rule-","l":"Decision Rule \\small d_t","p":["At each state s_t, we want to pick out an action a_t. There are 2 types of decision rules.","Markovian. d_t(s_t) returns an action by looking at current state.","History dependent. d_t(s_1,a_1\\dots s_{t-1}, a_{t-1}, s_t) returns an action by looking at all past states and actions.","The decision rules at each stage","Given a policy \\pi, we automatically get a sample path \\omega,","The probability of the path happening is:","A sample path also has a total reward W,","Each s_i in the sum is a random variable, so the expected total reward is:"]},{"i":"example-stochastic-shortest-paths","l":"****Example.**** Stochastic Shortest Paths","p":["Let each layer of the graph be the state at t=0, t=1, t=2, t=3.","At each stage, we can choose to go up or down. Since it’s stochastic, there’s a transition probability. Define:","For the path \\omega = \\text{SACF}, the probablity is \\Bbb P(\\text{path} = \\omega) = p_u^3 because we need to actually go up 3 times.","There are 2^3 possible sample paths (2 choice at each stage, 3 stages in total). Each path \\omega_i has a reward W(\\omega_i) and a probability \\Bbb P(\\omega_i).","So the expected reward is:"]},{"l":"Policy Backward Evaluation","p":["For policy \\pi, time t, define the value function:","reward function","current state","returns action depending on the history"]}],[{"i":"w7---convex-optimization","l":"W7 - Convex Optimization"},{"l":"Definitions","p":["A set S\\sub\\R^n is convex if for all \\bold{x,y}\\in S,\\lambda\\in[0,1], the line connecting \\bold{x,y} is also in S.","A function f:\\R^n\\to \\R is convex iff the epigraph of f(region above f) is convex.","For all \\bold{x,y}\\in\\text{Domain}(f), \\lambda\\in[0,1],","If -f is convex, then f is concave."]},{"i":"example-convex-functions","l":"**Example.** Convex Functions","p":["Let the domain be (-\\infty, \\infty),","f(x) = e^x, f(x) = x^2 are convex","f(x) = \\sqrt{x}, f(x) = x^3 are not convex"]},{"l":"Convex Optimization","p":["A convex optimization program looks like the following:","where f_0\\dots f_m: \\R^m\\to \\R are convex, h_1\\dots h_p: \\R^m\\to \\R are linear.","Let X be the set of solutions / feasible region:","Linear functions of the form \\bold{a^\\top x +b} are both convex and concave.","LP is a special case of convex optimization","Let f be convex","Constant multiple: af is convex","Addition: f + g is convex if g is also convex"]},{"i":"example","l":"**Example.**","p":["In \\R^2, consider the constraints f_1, f_2 \\leqslant 0 where:","We can see that the overlapped region is convex."]},{"l":"Optimality Status","p":["X=\\varnothing, optimal value = \\infty","|X| = \\infty, optimal value = -\\infty","We either have a finite solution or the solution is infinite. For example \\min e^{-x}, the optimal value is 0, but we need x\\to \\infty."]},{"i":"second-order-cone-programming-socp","l":"Second Order Cone Programming (SOCP)","p":["A general cone program has the form:","where \\|\\cdot\\|_2 is the l_2 norm.","A second order cone has the following form:","Linear programming is a special case of SOCP."]},{"l":"Semi-Definite Programming","p":["Matrix A is semi-definite if","a_{ij}\\geqslant 0","A^T = A","\\bold x^TA\\bold x\\geqslant 0 for all \\bold x with non-negative entries","This is equivalent to saying all eigenvalues of A is positive","A semi-definite program has the following form:","where A_i is a matrix, \\bold x is a vector, x_i is the i-th entry of \\bold x","A set S\\sub\\R^n is a cone if \\forall\\bold x\\in S, \\lambda \\geqslant 0, \\lambda\\bold x\\in S.","Non-negative multiples of \\bold x\\in S is also in S."]},{"l":"Lagrangian Dual Method","p":["Now we wish to know the dual form of convex programs. For the general primal problem (\\text{P}):","We need a variable for each f_i and each h_j.","To satisfy Thm. Weak Duality, we need {\\cal L}(\\bold x, \\lambda, \\mu)\\leqslant f_0(\\bold x).","If \\bold x is a solution to the program, then we know from the original constraints:","So there's no constraint on \\mu_j, and we need \\lambda_i\\geqslant 0 for \\sum^m_{i=1}\\lambda_if_i(\\bold x)\\leqslant 0 to hold."]}]]